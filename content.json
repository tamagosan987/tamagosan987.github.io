{"posts":[{"title":"Design Youtube","text":"requirementsfunctional upload a video watch a video non functionalapi designhttps://developers.google.com/youtube/v3/docs/videos/insert#request capacity estimationhigh-level architecture design database (schema, sql/nosql, sharding, replication)other topicsreference https://www.infoq.com/presentations/netflix-play-api/ https://netflixtechblog.com/high-quality-video-encoding-at-scale-d159db052746 https://openconnect.netflix.com/Open-Connect-Overview.pdf https://netflixtechblog.com/netflix-conductor-a-microservices-orchestrator-2e8d4771bf40","link":"/2023/02/19/Design-Youtube/"},{"title":"My New Post","text":"","link":"/2023/02/19/My-New-Post-1/"},{"title":"Get that job at ?","text":"Second problem: every “experienced” interviewer has a set of pet subjects and possibly specific questions that he or she feels is an accurate gauge of a candidate’s abilities. The question sets for any two interviewers can be widely different and even entirely non-overlapping. A classic example found everywhere is: Interviewer A always asks about C++ trivia, filesystems, network protocols and discrete math. Interviewer B always asks about Java trivia, design patterns, unit testing, web frameworks, and software project management. For any given candidate with both A and B on the interview loop, A and B are likely to give very different votes. A and B would probably not even hire each other, given a chance, but they both happened to go through interviewer C, who asked them both about data structures, unix utilities, and processes versus threads, and A and B both happened to squeak by. non-technical prep Long-term warming up means: study and practice for a week or two before the interview. Study a data-structures and algorithms book. practice the art of recognizing that certain problem classes are best solved with certain algorithms and data structures. Steven Skiena’s The Algorithm Design Manual / Introduction to Algorithms Have a friend interview you Short-term warming up means: get lots of rest the night before, and then do intense, fast-paced warm-ups the morning of the interview. Mental Prep You should go in humble, open-minded, and focused. Feel free to ask for help or hints if you’re stuck. Don’t try to change the subject and answer a different question. Ask if they care about syntax, and if they do, try to get it right. It’s OK (and highly encouraged) to ask a few clarifying questions, and occasionally verify with the interviewer that you’re on the track they want you to be on. don’t take too long before actually solving the problem, or some interviewers will give you a delay-of-game penalty. bring your own whiteboard dry-erase markers(pencil-thin ones at office supply stores) practice whiteboard space-management skills, such as not starting on the right and coding down into the lower-right corner in Teeny Unreadable Font. Tech Prep Algorithm Complexity: you need to know Big-O. Sorting: know how to sort. Don’t do bubble-sort. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quicksort and merge sort). Hashtables: hashtables are arguably the single most important data structure known to mankind. You absolutely have to know how they work.You should be able to implement one using only arrays in your favorite language, in about the space of one interview. Trees you should know about trees. know basic tree construction, traversal and manipulation algorithms. You should be familiar with binary trees, n-ary trees, and trie-trees at the very very least. You should be familiar with at least one flavor of balanced binary tree, whether it’s a red/black tree, a splay tree or an AVL tree. You should actually know how it’s implemented. You should know about tree traversal algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder. Graphs There are three basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list), and you should familiarize yourself with each representation and its pros and cons. You should know the basic graph traversal algorithms: breadth-first search and depth-first search. You should know their computational complexity, their tradeoffs, and how to implement them in real code. You should try to study up on fancier algorithms, such as Dijkstra and A*, if you get a chance. Whenever someone gives you a problem, think graphs. They are the most fundamental and flexible way of representing any kind of a relationship, so it’s about a 50-50 shot that any interesting design problem has a graph involved in it. Other data structures You should study up on as many other data structures and algorithms as you can fit in that big noggin of yours. You should especially know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. You should find out what NP-complete means. Math Some interviewers ask basic discrete math questions. spend some time before the interview refreshing your memory on the essentials of combinatorics and probability. You should be familiar with n-choose-k problems and their ilk – the more the better. Operating Systems know about processes, threads and concurrency issues. Know about locks and mutexes and semaphores and monitors and how they work. Know about deadlock and livelock and how to avoid them. Know what resources a processes needs, and a thread needs, and how context switching works, and how it’s initiated by the operating system and underlying hardware. Know a little about scheduling. Doug Lea’s Concurrent Programming in Java Coding You should know at least one programming language really well, and it should preferably be C++ or Java. You will be expected to write some code in at least some of your interviews. You will be expected to know a fair amount of detail about your favorite programming language. learn some statistics http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.htmlhttps://steve-yegge.medium.com/get-that-job-at-grab-eea6de1d8421","link":"/2023/02/20/Get-that-job-at/"},{"title":"My New Post","text":"lalala","link":"/2023/02/19/My-New-Post/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/02/19/hello-world/"},{"title":"系统设计套路","text":"requirement functional non-functional 设计monitoring system，那availability就是重中之重 力求在15分钟以内说完 usage pattern（是read heavy还是write heavy） scalability highly available consistency（strong consistency，还是eventual consistency，是否需要read-your-own-write consistency） latency是否有要求 data durability是否有要求 idempotency（对于付款相关的系统一定强调这个） API design 对于每个API，定好名字，定好输入是哪些，输出是哪些就行了 RPC还是Rest API Rest API的知识 synchronized API和asynchronized API (比如有的时候一个操作需要执行很久，这时候一般选择设计一个async API先立刻返回一个id给caller，让caller拿着id去查询操作的执行情况，而不应该只设计一个sync API让caller一直阻塞在那里) Capacity estimation。算QPS和bandwidth的时候，要把average value和peak value都算一下 QPS (read, write) network bandwidth(upload, download) disk storage(算disk storage的时候，直接说“假设我们存5年的数据”，因为5年约等于2000天，好算，同时不要忘记存在disk上的数据都有replication，一般直接说”let’s assume the replication factor is 3”，然后乘以3就行了。) High-level architecture design。 Database (schema, sql/nosql, sharding, replication)。 说schema的时候一般说一下有哪些表，每张表有哪些column，谁是primary key就行了。 sql/nosql(根据具体情况来，比如订票系统，牵扯到多张表的distributed transaction，那么只能是sql，还有购物相关的系统，user-order-item这些东西是天生relational的，那么sql也是更好的选择。) sharding (一般都有一个”shard by user id”还是”shard by item id”的trade off，如果是user id，那么会有Hotspotting问题（因为有的user特别活跃），如果是item id，虽然可以解决hotspotting问题，但是如果需要读某个user的数据，就需要访问所有的shard。) 6.Other topics（cache/how to scale/push vs. pull/monitoring/rate limiting/failure handling/logging）。 from: https://www.1point3acres.com/bbs/thread-768263-1-1.html","link":"/2023/02/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A5%97%E8%B7%AF/"},{"title":"Design Twitter","text":"requirementsfunctionalnon functional read heavy api designhttps://developer.twitter.com/en/docs/twitter-api/tweets/manage-tweets/api-reference/post-tweets https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-id-reverse-chronological capacity estimationhigh-level architecture design database (schema, sql/nosql, sharding, replication)other topicsreferencehttps://www.infoq.com/presentations/Twitter-Timeline-Scalability/ https://www.youtube.com/watch?v=VttXHNveuwI https://blog.twitter.com/engineering/en_us/a/2010/introducing-flockdb https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake","link":"/2023/02/20/Design-Twitter/"},{"title":"leetcode总结","text":"Time Based Key-Value Store group by key. binary search.(timstamp is strictly increasing, use treemap otherwise)","link":"/2023/02/20/leetcode%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"sd","slug":"sd","link":"/tags/sd/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[],"pages":[]}